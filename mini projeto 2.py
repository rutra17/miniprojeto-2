# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XkVl1DRaRCh-tiAIGNMvu9arJ3fS0Uyh
"""

import threading
import time
import random

# Parâmetros da linha de produção
BUFFER_CAPACITY = 10  # Capacidade do buffer
NUM_PRODUCERS = 2  # Número de produtores
NUM_CONSUMERS = 3  # Número de consumidores
NUM_TIMESTEPS = 100  # Número total de timesteps

# Buffer compartilhado
buffer = []

# Semáforos
sem_espaco_disponivel = threading.Semaphore(BUFFER_CAPACITY)
sem_itens_disponiveis = threading.Semaphore(0)

# Mutex para acesso ao buffer
mutex = threading.Lock()

# Variáveis de controle
total_produzido = 0
total_consumido = 0

# Adicione esta variável global
parar_execucao = False


# Função do produtor
def produtor(id_produtor):
    global total_produzido, parar_execucao
    for _ in range(NUM_TIMESTEPS):
        if parar_execucao:
            break

        # Tenta adquirir espaço no buffer com timeout
        if not sem_espaco_disponivel.acquire(timeout=1):  # Evita deadlocks
            print(f"Produtor-{id_produtor}: Timeout ao esperar espaço disponível!")
            break

        try:
            with mutex:  # Acesso exclusivo ao buffer
                item = f"Peça-{random.randint(1, 100)}"
                buffer.append(item)
                total_produzido += 1
                print(f"Produtor-{id_produtor}: Adicionou {item} ao buffer. Itens no buffer: {len(buffer)}")
        finally:
            # Libera o semáforo de itens disponíveis
            sem_itens_disponiveis.release()

        # Simula o tempo de produção
        time.sleep(random.uniform(0.1, 0.5))


# Função do consumidor
def consumidor(id_consumidor):
    global total_consumido, parar_execucao
    for _ in range(NUM_TIMESTEPS):
        if parar_execucao:
            break

        # Tenta adquirir itens disponíveis com timeout
        if not sem_itens_disponiveis.acquire(timeout=1):  # Evita deadlocks
            print(f"Consumidor-{id_consumidor}: Timeout ao esperar por itens disponíveis!")
            break

        try:
            with mutex:  # Acesso exclusivo ao buffer
                if buffer:
                    item = buffer.pop(0)
                    total_consumido += 1
                    print(f"Consumidor-{id_consumidor}: Retirou {item} do buffer. Itens no buffer: {len(buffer)}")
                else:
                    print(f"Consumidor-{id_consumidor}: Buffer vazio!")
        finally:
            # Libera o semáforo de espaço disponível
            sem_espaco_disponivel.release()

        # Simula o tempo de consumo
        time.sleep(random.uniform(0.1, 0.5))


# Controle de execução
threads = []

# Criando threads de produtores
for i in range(NUM_PRODUCERS):
    thread = threading.Thread(target=produtor, args=(i + 1,))
    threads.append(thread)
    thread.start()

# Criando threads de consumidores
for i in range(NUM_CONSUMERS):
    thread = threading.Thread(target=consumidor, args=(i + 1,))
    threads.append(thread)
    thread.start()

# Após o tempo ou o número de timesteps, definir "parar_execucao = True"
time.sleep(35)  # Ajuste para o tempo necessário
parar_execucao = True

# Aguardar as threads finalizarem
for thread in threads:
    thread.join()

# Relatório final
print("\n--- Relatório Final ---")
print(f"Total de itens produzidos: {total_produzido}")
print(f"Total de itens consumidos: {total_consumido}")
print(f"Itens restantes no buffer: {len(buffer)}")

import threading
import time
import random
from queue import Queue
import matplotlib.pyplot as plt

# Classe LinhaDeProducao
class LinhaDeProducao:
    def __init__(self, capacidade_buffer):
        self.buffer = Queue(capacidade_buffer)
        self.capacidade = capacidade_buffer
        self.sem_espaco = threading.Semaphore(capacidade_buffer)
        self.sem_itens = threading.Semaphore(0)
        self.mutex = threading.Lock()
        self.total_produzido = 0
        self.total_consumido = 0
        self.parar_execucao = False
        self.historico_buffer = []  # Lista para armazenar histórico do buffer
        self.tempo_historico = []  # Lista para armazenar timestamps do histórico

    def produzir(self, id_produtor):
        while not self.parar_execucao:
            # Tenta adquirir espaço no buffer com timeout
            if not self.sem_espaco.acquire(timeout=1):
                print(f"Produtor-{id_produtor}: Timeout ao esperar espaço disponível!")
                break

            try:
                with self.mutex:  # Acesso exclusivo ao buffer
                    item = f"Peça-{random.randint(1, 100)}"
                    self.buffer.put(item)
                    self.total_produzido += 1
                    print(f"Produtor-{id_produtor}: Adicionou {item} ao buffer. Itens no buffer: {self.buffer.qsize()}")
                    # Salva estado do buffer
                    self.historico_buffer.append(self.buffer.qsize())
                    self.tempo_historico.append(time.time())
            finally:
                # Libera o semáforo de itens disponíveis
                self.sem_itens.release()

            # Simula o tempo de produção
            time.sleep(random.uniform(0.1, 0.5))

    def consumir(self, id_consumidor):
        while not self.parar_execucao:
            # Tenta adquirir itens disponíveis com timeout
            if not self.sem_itens.acquire(timeout=1):
                print(f"Consumidor-{id_consumidor}: Timeout ao esperar por itens disponíveis!")
                break

            try:
                with self.mutex:  # Acesso exclusivo ao buffer
                    if not self.buffer.empty():
                        item = self.buffer.get()
                        self.total_consumido += 1
                        print(f"Consumidor-{id_consumidor}: Retirou {item} do buffer. Itens no buffer: {self.buffer.qsize()}")
                        # Salva estado do buffer
                        self.historico_buffer.append(self.buffer.qsize())
                        self.tempo_historico.append(time.time())
                    else:
                        print(f"Consumidor-{id_consumidor}: Buffer vazio!")
            finally:
                # Libera o semáforo de espaço disponível
                self.sem_espaco.release()

            # Simula o tempo de consumo
            time.sleep(random.uniform(0.1, 0.5))

# Parâmetros da linha de produção
BUFFER_CAPACITY = 30  # Capacidade do buffer
NUM_PRODUCERS = 5  # Número de produtores (ajustado para testes menores)
NUM_CONSUMERS = 3  # Número de consumidores (ajustado para testes menores)

# Instância da linha de produção
linha = LinhaDeProducao(BUFFER_CAPACITY)

# Controle de execução
threads = []

# Criando threads de produtores
for i in range(NUM_PRODUCERS):
    thread = threading.Thread(target=linha.produzir, args=(i + 1,))
    threads.append(thread)
    thread.start()

# Criando threads de consumidores
for i in range(NUM_CONSUMERS):
    thread = threading.Thread(target=linha.consumir, args=(i + 1,))
    threads.append(thread)
    thread.start()

# Após o tempo, definir "parar_execucao = True"
time.sleep(10)  # Ajuste para o tempo necessário
linha.parar_execucao = True

# Aguardar as threads finalizarem
for thread in threads:
    thread.join()

# Relatório final
print("\n--- Relatório Final ---")
print(f"Total de itens produzidos: {linha.total_produzido}")
print(f"Total de itens consumidos: {linha.total_consumido}")
print(f"Itens restantes no buffer: {linha.buffer.qsize()}")

# Plotar gráfico do histórico do buffer
plt.figure(figsize=(10, 5))
tempo_normalizado = [t - linha.tempo_historico[0] for t in linha.tempo_historico]
plt.plot(tempo_normalizado, linha.historico_buffer, label="Tamanho do Buffer", color="blue")
plt.axhline(BUFFER_CAPACITY, color="red", linestyle="--", label="Capacidade Máxima")
plt.xlabel("Tempo (s)")
plt.ylabel("Itens no Buffer")
plt.title("Histórico do Buffer")
plt.legend()
plt.grid()
plt.show()